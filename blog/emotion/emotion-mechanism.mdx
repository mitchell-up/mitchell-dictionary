# Emotion의 동작원리 이해하기
대표적인 CSS in JS 라이브러리인 Emotion의 소스코드를 분석하면서 동작원리를 이해해보겠습니다. 동작원리를 이해하게 되면 제대로 활용해야할 방안과 하지 말아야할 내용을 정리할 수 있는 근거가 됩니다. 이 글에서는 `@emotion/react`와 cssProp를 중심으로 전반적인 작동흐름을 다룹니다.

### 이 글에서의 분석 방법
무작정 코드부터 들여다본다고 쉽게 이해할 수 있는 것은 아닙니다. 평소에 Emotion을 사용했던 방식으로 부터 시작해서 하나씩 짚어가면서 소스코드를 이해하고 흐름을 정리하겠습니다. (코드 한줄한줄에 대한 해석을 정리하지는 않습니다.)

### 주의깊게 볼 패키지
이모션은 스타일을 생성하고 최적화하기 위한 많은 패키지들을 가지고 있습니다. 그러나 전체적인 흐름을 이해하는데는 다음의 패키지들만 확인하셔도 좋습니다.  
[전체 패키지 보기](https://github.com/emotion-js/emotion/tree/main/packages)

```bash
packages
├── cache
├── css
├── memoize
├── react
├── serialize
├── server
├── sheet
├── use-insertion-effect-with-fallbacks
├── utils
├── weak-memoize
```

### 전체적인 동작흐름
1. `@emotion/react`에 의한 JSX 트랜스파일링
2. 브라우저에서 React 렌더시작
3. Emotion cache 생성
3. cssProp에 전달된 스타일 직렬화
4. 직렬화된 스타일을 캐시에 등록
5. 캐시에 등록된 스타일을 캐시에 삽입
6. 캐시에 삽입되면 stylis로 스타일을 CSSRule로 컴파일
7. 컴파일된 CSSrule을 HTML문서에 삽입
8. 본래의 컴포넌트를 렌더

1번은 실제 코드가 실행되기 전인 `컴파일타임`에서 이루어지는 동작이고, 나머지는 브라우저에서 JavaScript 파일이 다운로드 되고 코드가 실제로 실행되는 `런타임`에서 이루어지는 동작입니다.

---

## 01. JSX 트랜스파일링
Emotion으로 작성된 코드가 브라우저에서 정상적으로 작동될 수 있도록 변환되는 과정입니다.

간단한 컴포넌트를 작성해보겠습니다.
```tsx
function Simple() {
  return (
    <button css={{
      backgroundColor: 'blue'
    }}>
      간단한 버튼입니다.
    </button>
  )
}
```

cssProp를 사용하기 위해 타입스크립트 tsconfig의 `jsxImportSource`를 `@emotion/react`로 설정하고 트랜스파일링 해보면 다음과 같이 변환됩니다.
```js
import { jsx as _jsx } from "@emotion/react/jsx-runtime";
function Simple() {
    return (_jsx("button", { css: {
            backgroundColor: 'blue'
        }, children: "\uAC04\uB2E8\uD55C \uBC84\uD2BC\uC785\uB2C8\uB2E4." }));
}
```  

---

## 02. 브라우저에서 React 컴포넌트 렌더시작
위에서 트랜스파일링된 소스코드는 브라우저에서 실제로 실행되며, 본격적으로 런타임에서 스타일코드 생성하고 주입합니다. 모든 흐름은 위에서 본 `_jsx` 함수의 실행으로부터 시작됩니다.
```tsx title="emotion/packages/react/src/jsx-runtime.js"
import * as ReactJSXRuntime from 'react/jsx-runtime'
import Emotion, { createEmotionProps } from './emotion-element'
import { hasOwnProperty } from './utils'

//...

export function jsx(type: any, props: any, key: any) {
  if (!hasOwnProperty.call(props, 'css')) {
    return ReactJSXRuntime.jsx(type, props, key)
  }

  return ReactJSXRuntime.jsx(Emotion, createEmotionProps(type, props), key)
}

//...
```

[소스코드 바로가기](https://github.com/emotion-js/emotion/blob/main/packages/react/src/jsx-runtime.js)

`@emotion/react/jsx-runtime` 코드를 들여다보면, React의 jsx가 cssProp를 처리할 수 있도록 확장하고 있습니다. jsx의 파라미터 중 type에 `Emotion`을, props에 `createEmotionProps(type, props)`를 전달하고 있습니다.

### Emotion
첫번째로 전달되는 파라미터는 `Emotion`입니다. jsx는 React의 `createElement`로 변환되고, 그 함수의 첫번째 파라미터는 string, HTMLElement, Component 등으로 지정되어 있습니다. 그리고 네이밍 컨벤션이 PascalCase인 점을 미루어 보아 `Emotion`은 리액트 컴포넌트인 것으로 예상해볼 수 있습니다.
```tsx title="emotion/packages/react/src/emotion-element.js"
let Emotion = /* #__PURE__ */ withEmotionCache<any, any>(
  (props, cache, ref) => {
    //...

    return (
      <>
        <Insertion
          cache={cache}
          serialized={serialized}
          isStringTag={typeof WrappedComponent === 'string'}
        />
        <WrappedComponent {...newProps} />
      </>
    )
  }
)
```
[소크코드 바로가기](https://github.com/emotion-js/emotion/blob/main/packages/react/src/emotion-element.js)  

예상대로 `Element` 변수는 컴포넌트를 반환하고 있습니다. 세부내용도 살펴보겠지만, 큰 그림에서 먼저 보겠습니다.
1. `withEmotionCache`라는 HOC(High order Component)로 컴포넌트를 감싸고 있다. 네이밍으로 유추하자면, emotion의 cache 처리와 관련한 로직이 있을 것으로 예상할 수 있다.
2. 원래의 컴포넌트는 `<Insertion/>`이라는 컴포넌트와 함께 반환되고 있다. 네이밍으로 유추하자면, 스타일의 삽입이 이루어지는 곳이라고 예상할 수 있다.

### createEmotionProps
Emotion컴포넌트에서 사용할 Props를 생성하는 함수입니다. 주요 역할은 컴포넌트 타입을 결정 cssProp의 유효성을 검사, 개발환경을 위한 디버깅 처리 등 있습니다.

---

## 03. Emotion Cache 생성
여기에서 자세히 설명하진 않지만, Emotion에서는 [contextAPI](https://react.dev/learn/passing-data-deeply-with-context)를 활용하여 `EmotionCacheContext`를 생성하고 Emotion의 스타일주입이 필요한 컴포넌트에서 Cache에 접근할 수 있도록 하고 있습니다.
```tsx title="emotion/packages/react/src/context.js"
let withEmotionCache = function withEmotionCache<Props, Ref: React.Ref<*>>(
  func: (props: Props, cache: EmotionCache, ref: Ref) => React.Node
): React.AbstractComponent<Props> {
  // $FlowFixMe
  return forwardRef((props: Props, ref: Ref) => {
    // the cache will never be null in the browser
    let cache = ((useContext(EmotionCacheContext): any): EmotionCache)

    return func(props, cache, ref)
  })
}
```
[소스코드 바로가기](https://github.com/emotion-js/emotion/blob/main/packages/react/src/context.js)

위에서 간략하게 살펴본 `Emotion` 컴포넌트는 withEmotionCache라는 HOC로 랩핑되어 있었습니다. `withEmotionCache`는 생성된 cache를 useContext를 통해서 가져와 렌더링 대상이 되는 함수에 전달하는 공통 로직을 가지고 있습니다. 이에 따라 `Emotion`에서 작성된 내부에서 cache에 접근하여 효율적으로 스타일을 생성할 수 있게 됩니다.

---

## 04. cssProp에 전달된 스타일 직렬화
`Emotion` 컴포넌트의 로직을 하나씩 살펴보겠습니다.
```tsx title="emotion/packages/react/src/emotion-element.js"
let Emotion = /* #__PURE__ */ withEmotionCache<any, any>(
  (props, cache, ref) => {
    let cssProp = props.css
    
    if (
      typeof cssProp === 'string' &&
      cache.registered[cssProp] !== undefined
    ) {
      cssProp = cache.registered[cssProp]
    }

    let WrappedComponent = props[typePropName]
    let registeredStyles = [cssProp]
    let className = ''

    if (typeof props.className === 'string') {
      className = getRegisteredStyles(
        cache.registered,
        registeredStyles,
        props.className
      )
    } else if (props.className != null) {
      className = `${props.className} `
    }

    let serialized = serializeStyles(
      registeredStyles,
      undefined,
      React.useContext(ThemeContext)
    )

    // ...

    className += `${cache.key}-${serialized.name}`

    // ...
  }
)
```
[소크코드 바로가기](https://github.com/emotion-js/emotion/blob/main/packages/react/src/emotion-element.js)  

1. `cssProp`이 `string`이고 그 값을 키로 캐시에 등록된 스타일이 있으면 `cssProp`에 캐시에 등록된 값을 할당합니다.
2. `cssProp`을 배열의 첫번째 요소로 추가하여 `registeredStyles`를 초기화합니다.
3. `getRegisteredStyles` 함수를 통해서 `registeredStyles`에 캐시에 등록된 스타일들을 추가하고, 새로운 className을 생성합니다.
4. `serializeStyles`로 `registeredStyles`를 직렬화 한다. 

이 로직의 핵심은 결국,cssProp으로 들어온 값을 cache에서 확인하여 이미 등록된게 있으면 직렬화가 완료된 스타일을 가져오고, 없으면 직렬화를 진행한다는 것입니다.

맨 위에서 간단한 예시로 들었던 Simple 컴포넌트로 다시 설명하자면,
```tsx
<button css={{
  backgroundColor: 'blue'
}}>
  간단한 버튼입니다.
</button>
```
cssProp에 전달한 `{ backgroundColor: 'blue' }`가 `serializeStyles`에 의해서 직렬화됩니다.

### getRegisteredStyles
파라미터로 전달받은 값으로부터 캐시에 등록된 스타일문자열을 가져오고, 등록된 값이 없다면 해당 클래스네임은 다시 반환해주는 함수입니다.  
[소스코드 바로가기](https://github.com/emotion-js/emotion/blob/main/packages/utils/src/index.js#L6)


### serializeStyles
Emotion에서 스타일 삽입으로 처리할 수 있는 형태인 `SerializedStyles` 객체로 직렬화 해주는 함수입니다. Object형식이든 Tagged Template Literal형식이든 저희가 작성했던 스타일을 처리합니다.

```tsx title="emotion/packages/serialize/src/index.js"
export const serializeStyles = function (
  args: Array<Interpolation>,
  registered: RegisteredCache | void,
  mergedProps: void | Object
): SerializedStyles {
  // args를 순회하며 여러 타입으로 작성된
  // 스타일들을 처리하여 하나의 문자열로 생성하고
  // 직렬화된 스타일 객체를 반환함.
}
```
[소스코드 바로가기](https://github.com/emotion-js/emotion/blob/main/packages/serialize/src/index.js)  

1. `args`가 1개이고, `SerializedStyles`이라면 직렬화 과정 없이 바로 그 값을 반환합니다.
2. 1번이 아니라면 모든 `args` 요소에 대해 반복문을 돌면서 `handleInterpolation`함수를 통해 스타일 문자열을 만듭니다.
  - `args`가 <code>css\`color: blue;\`</code>과 같은 [Tagged Template Literal](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals)로 들어오면 고정문자열에 `handleInterpolation` 함수를 거친 동적변수 문자열을 합쳐 스타일 문자열을 만듭니다.
3. 생성된 스타일 문자열을 바탕으로 스타일의 hash name을 만듭니다.
4. hash name, 스타일 문자열 등으로 `SerializedStyles` 객체를 만들어 반환합니다.

### handleInterpolation
함수, 문자열, 숫자, 객체 등 스타일을 위해 작성된 값을 각 케이스 별로 처리하여 스타일 문자열로 변환합니다. 객체의 경우는 `createStringFromObject` 함수를 통해서 문자열 처리를 진행합니다. 이미 직렬화된 스타일의 경우는 역시 별도 처리없이 바로 반환됩니다.  
[소스코드 바로가기](https://github.com/emotion-js/emotion/blob/main/packages/serialize/src/index.js)

### createStringFromObject
이 함수는 전달받은 객체의 key와 value를 바탕으로 순회하며 스타일 문자열을 만들어 반환합니다.  
[소스코드 바로가기](https://github.com/emotion-js/emotion/blob/main/packages/serialize/src/index.js)

위 과정들을 거쳐서 생성된 스타일 문자열인 `serialized` 변수는 최종 반환 값인 `<Insertion/>` 컴포넌트로 캐시와 함께 전달되어 스타일에 삽입됩니다.

---

